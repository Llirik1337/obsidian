## Мотивация
При разработки ПО по принципам SOLID экономиться время на добавления или изменения функциональности ПО, а так же улучшается читаемость кода для других разработчиков, и в следствии этого код легко переиспользовать
## Термины
**Программные сущность** - это классы, модули, функции и тп
## SRP (Single Responsibility Principle, Принцип единственной ответственности)
#SRP 
**У каждой абстракции должна быть только одна причина для изменения**
![[Pasted image 20240805200826.png]]
### Ссылки
- https://www.youtube.com/watch?v=O4uhPCEDzSo&list=PLmqFxxywkatQNWLG1IZYUhKoQrnuZHqaK&index=1&pp=iAQB

## OCP (Open Closed Principle, Принцип открытости/закрытости)
#OCP

**Программные сущности должны быть открыты для расширения, но закрыты для изменения**
- **Отрыто** для расширения означает что каждая программная сущность должна быть открыта для добавления новой функциональности
![[Pasted image 20240805183011.png]]
### Ссылки
- https://www.youtube.com/watch?v=x5OtQiKOG-Q&list=PLmqFxxywkatQNWLG1IZYUhKoQrnuZHqaK&index=2&pp=iAQB
## LSP (The Liskov Substitution Principle, Принцип подстановки Барбары Лисков)
#LSP
Формулировка Роберта Мартина: ***функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом***

Формулировка Герба Саттера и Андрея Александреску: ***подкласс не должен требовать от вызывающего кода больше чем базовый класс и не должен предоставлять вызывающему коду меньше чем базовый класс***

Если в аргументах функции объявлен базовый тип, то наследники этого базового типа должны без всяких эксцессов работать так же как и базовый тип

Этот принцип позволяет предотвратить ошибки, например:
Имеется класс Rect(Прямоугольник) и мы наследуем от него класс Square(Квадрат), так как мы знаем из математики что квадрат это подмножество прямоугольника, и в связи с этим мы имеем ситуацию при которой мы можем положить квадрат в массив с прямоугольниками и скажем у становить всем в этом массиве стороны a равную 10 и b равную 5 и посчитать площадь, и ожидается что площадь каждого будет 50, но это так не будет, так как в этом массиве есть квадрат в лучшем случаи будет другая площадь, а в худшем будет выброшена ошибка "Not  implemented" или подобная
![[Pasted image 20240805190118.png]]

```ad-warning
Не во всех случаях возможно следовать этому правилу, например unit тестирование, где нужно замокать DB в которой 8000 методов, но в место этого ты мокаешь только те который используешь, а все остальные выкидываю ошибку "Not implemented"
```


![[Pasted image 20240805184443.png]]
### Ссылки
- https://www.youtube.com/watch?v=NqvwYcjrwdw&list=PLmqFxxywkatQNWLG1IZYUhKoQrnuZHqaK&index=3

## ISP (The Interface Segregation Principle, Принцип Разделения Интерфейса)
#ISP
**Клиенты не должны зависеть от методов которые они не используют, то есть если какой-то метод интерфейса не используется клиентом, то изменения этого метода не должны приводить к необходимости вносить изменения в клиентский код**

![[Pasted image 20240805192307.png]]![[Pasted image 20240805192909.png]]
## DIP (The Dependency Inversion Principle, Принцип инверсии зависимостей)
- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций
```ad-note
Должны использовать все классы через интерфейсы. Так как это дает возможность расширить функциональность. Например реализовав паттерн Proxy
```
### Ссылки
- https://www.youtube.com/watch?v=Bw6RvCSsETI&list=PLmqFxxywkatQNWLG1IZYUhKoQrnuZHqaK&index=5
